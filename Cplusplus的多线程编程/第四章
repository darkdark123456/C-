##### ***第四章 并发操作的同步***

###### **本章**内容**

​    **1 等待事件发生**
​    **2 使用future等待一次性事件**
​    **3 等待时间期限**
​    4 运用同步操作简化代码**

```c++
[概述]
  我们时常会遇到这么一种情况，一个线程thd2想要执行某个特定任务必须拿到前一个线程thd1的执行结果，一般而言，后一个线程需要等待前一个线程，只要设置一个"任务完成"的标志，thd2通过定期的查询该标记以判断当前能否开始执行，但这远非理想方案，主要原因是定期查询浪费了大量的时间。上述线程的同步操作很常见，c++专门提供了工具 条件变量（conditional variable）和future，还针对future增加了新式的同步工具，线程闩latch和线程卡barrier,本章我们使用条件变量，线程闩，线程卡和future来等待事件，以简化同步操作。
  
  对于上述的等待事件，我们理想的情况是thd2不必定期查询标记，而是在thd1产出结果时立马通知thd2，在这之前，thd2可以执行其他任务，当thd2拿到结果时在执行这个特定任务，这就会大大提升系统的高并发行。
  
```

***4.1.1 等待特定事件或等待某个条件***

```c++
[概述]
     假设你正在乘坐一辆火车，在你确保要在正确的地点下车，一种做法是彻夜不眠留心火车的停靠点，那么你就不会错过，可是，到达站后你会神情疲惫，或者你可以按预定到达时间设置一个闹钟随后安心入睡，这种方式还算小小的管用，一般来说你不会误站，但也可能不巧，火车也许比预定时间早到站，又或者闹钟的电池坏了，你会因此错过下车点。
最理想的方式是安排专门的人员或者设备，无论什么时候到达目的站点，都可以将你唤醒，那你大可高枕无忧。我们翻译成多线程的语言来看，如果线程甲需要等待线程乙完成任务，线程甲可以采取以下不同的方式。

           
[方式1]
    在共享数据内部维护一个标志，受互斥保护，线程乙完成任务后就设置标志成立，该方式存在双重浪费，1是线程甲不断的检查标志是否成立，浪费了这一部分的处理时间，2是一旦互斥被锁住，线程甲乙都必须等待解锁，3是在线程甲持锁检查标志的时候线程乙恰好想要设置标记成立，线程乙必须等待，这就浪费了线程乙的时间，总而言之，让线程等待是一件不好的事情。

[方式2]
    使用std::this_thread::sleep_for()进行周期性的检查标志,具体代码如下:

bool flag;
std::mutex mtx;
void wait_for_flag(){
    std::unique_lock<std::mutex> lock(mtx);
    while(!flag){
        lock.unlock();
        std::this_thread::sleep_for(100ms);
        lock.lock()
    }
}

         
      
```

锁存总线

在多核CPU架构中，多个核心可能同时访问共享内存。为了确保多线程程序的正确性，需要一些机制来防止不同核心同时修改同一块内存区域，从而避免数据的不一致性。

锁定内存总线是一种硬件机制，用于实现原子操作和临界区的互斥访问。当一个核心要执行原子操作时，它会发送一个请求来锁定内存总线。这样一来，其他核心的访问请求会被阻塞，直到原子操作完成并释放内存总线锁。

在x86架构中，使用`lock`前缀可以实现对内存总线的锁定。例如，`lock add [atomicInt], 5` 指令会将内存总线锁定，确保整个加法操作是原子的。这意味着在执行这个指令期间，其他核心无法访问相同的内存区域。

内存总线锁定的代价比较高，因为它可能导致性能下降。当多个核心竞争同一个内存位置时，内存总线锁定可能会引起其他核心的访问请求被阻塞，从而降低并行性。因此，现代CPU设计通常会采用更智能的方式来处理原子操作，例如缓存行锁定和更高级的缓存一致性协议，以尽量减少对内存总线的锁定。

需要注意的是，内存总线锁定是一种底层的硬件机制，通常在高级编程语言中不需要直接操作。C++中的原子操作使用了编译器和硬件提供的机制来实现线程安全的操作，而不需要程序员显式地操纵内存总线锁定。



缓存一致协议

当多个处理器核心同时访问共享内存时，需要确保数据的一致性和原子性。为了实现这一点，现代CPU采用了一系列复杂的机制，包括锁定总线、刷新缓存行和延迟指令执行。

1. **锁定内存总线**：
   锁定内存总线是一种硬件机制，用于实现原子操作和临界区的互斥访问。当一个核心要执行原子操作时，它会发送一个请求来锁定内存总线。这样一来，其他核心的访问请求会被阻塞，直到原子操作完成并释放内存总线锁。

2. **刷新缓存行**：
   多核处理器中，每个核心都有自己的缓存，用于加速数据的访问。但是，当一个核心修改了一个内存位置的值时，其他核心的缓存中可能还保存着旧值。为了确保数据一致性，需要刷新（或使无效）涉及修改的缓存行，以便其他核心可以看到最新的值。

3. **延迟指令执行**：
   现代CPU通常会采用乱序执行（Out-of-Order Execution）的方式来提高指令级并行性。这意味着CPU可能会以不同于程序顺序的方式执行指令。然而，在存在原子操作的情况下，延迟的指令执行可能会导致问题。为了确保原子操作的正确性，CPU会在某些情况下延迟某些指令的执行，以保持指令的顺序性。

以上这些机制的目标是确保多核CPU下的数据一致性和线程安全。这样可以防止不同核心之间的竞争条件、死锁和数据不一致等问题。然而，这些机制的引入可能会导致性能的降低，因为锁定总线、刷新缓存行和延迟指令执行都会增加指令的等待时间，从而影响了整体的执行速度。

为了平衡数据一致性和性能，现代CPU通常会采用更智能的方法，如缓存一致性协议。常见的缓存一致性协议包括MESI（Modified, Exclusive, Shared, Invalid）协议，它通过在不同核心之间协调缓存的状态来维护数据一致性。这样，大部分情况下，锁定总线和刷新缓存行等低级机制可以被高效地处理，从而提供更好的性能。
